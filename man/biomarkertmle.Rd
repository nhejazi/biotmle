% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biomarkertmle-wrapper.R
\name{biomarkertmle}
\alias{biomarkertmle}
\title{Biomarker Evaluation with Targeted Minimum Loss-Based Estimation of the ATE}
\usage{
biomarkertmle(se, varInt, normalized = TRUE, ngscounts = FALSE,
  parallel = TRUE, bppar_type = NULL, future_param = NULL,
  family = "gaussian", subj_ids = NULL, g_lib = c("SL.glm",
  "SL.randomForest", "SL.nnet", "SL.polymars", "SL.mean"),
  Q_lib = c("SL.glm", "SL.randomForest", "SL.nnet", "SL.mean"))
}
\arguments{
\item{se}{(SummarizedExperiment) - containing expression or next-generation
sequencing data in the "assays" slot and a matrix of phenotype-level data
in the "colData" slot.}

\item{varInt}{(numeric) - indicating the column of the design matrix
corresponding to the treatment or outcome of interest (in the
\code{colData} slot of the \code{SummarizedExperiment} argument "se").}

\item{normalized}{(logical) - whether the data included in the \code{assay}
slot of the input \code{SummarizedExperiment} object has been normalized
already. The default is set to \code{TRUE} since it is expected that most
practitioners would apply normalization methods appropriate to the type of
assay being analyzed. If set to \code{FALSE}, median normalization is
performed for microarray (i.e., non-RNA-seq) data.}

\item{ngscounts}{(logical) - whether the data are counts generated from a
next-generation sequencing (NGS) experiment (e.g., RNA-seq). The default
setting assumes continuous expression measures as generated by platforms
that are microarray-type (i.e., so-called "targeted" assays).}

\item{parallel}{(logical) - whether or not to use parallelization in the
estimation procedure. Invoking parallelization happens through a
combination of calls to \code{future} and \code{BiocParallel}. If this
argument is set to \code{TRUE}, \code{future::multiprocess} is used,
and if \code{FALSE}, \code{future::sequential} is used, alongside
\code{BiocParallel::bplapply}. Other options for evaluation through
futures may be invoked by setting the argument \code{future_param}.}

\item{bppar_type}{(character) - specifies the type of backend to be used with
the parallelization invoked by \code{BiocParallel}. Consult the manual page
for \code{BiocParallel::BiocParallelParam} for possible types and
descriptions on their appropriate uses. The default for this argument is
\code{NULL}, which silently uses \code{BiocParallel::DoparParam}.}

\item{future_param}{(character) - specifies the type of parallelization to be
invoked when using futures for evaluation. For a list of the available
types, please consult the documentation for \code{future::plan}. The default
setting (this argument set to \code{NULL}) silently invokes
\code{future::multiprocess}. Be careful if changing this setting.}

\item{family}{(character) - specification of error family: "binomial" or
"gaussian".}

\item{subj_ids}{(numeric vector) - subject IDs to be passed directly to
subject should have the exact same numerical identifier; coerced to class
\code{numeric} if not provided in the appropriate form.}

\item{g_lib}{(char vector) - library of learning algorithms to be used in
fitting the propensity score (the nuisance parameter denoted "g" in the
literature on targeted minimum loss-based estimation).}

\item{Q_lib}{(char vector) - library of learning algorithms to be used in
fitting the outcome regression (the nuisance parameter denoted "Q" in the
literature on targeted minimum loss-based estimation).}
}
\value{
S4 object of class \code{biotmle}, generated by sub-classing
 \code{SummarizedExperiment}, with additional slots containing \code{tmleOut}
 and \code{call}, among others, containing TMLE-based estimates of the
 relationship between a biomarker and exposure or outcome variable and the
 original call to this function (for user reference), respectively.
}
\description{
Computes the causal target parameter defined as the difference between the
biomarker expression values under treatment and those same values under no
treatment, using Targeted Minimum Loss-Based Estimation.
}
\examples{
library(dplyr)
library(biotmleData)
data(illuminaData)
library(SummarizedExperiment)
"\%ni\%" = Negate("\%in\%")

colData(illuminaData) <- colData(illuminaData) \%>\%
     data.frame \%>\%
     dplyr::mutate(age = as.numeric(age > median(age))) \%>\%
     DataFrame

varInt_index <- which(names(colData(illuminaData)) \%in\% "benzene")

biomarkerTMLEout <- biomarkertmle(se = illuminaData[1:2, ],
                                  varInt = varInt_index,
                                  parallel = FALSE,
                                  family = "gaussian",
                                  g_lib = c("SL.mean", "SL.glm"),
                                  Q_lib = "SL.mean"
                                 )
}
