utils::globalVariables(c("assay<-"))

#' Biomarker Evaluation with Targeted Minimum Loss-Based Estimation of the ATE
#'
#' Computes the causal target parameter defined as the difference between the
#' biomarker expression values under treatment and those same values under no
#' treatment, using Targeted Minimum Loss-Based Estimation.
#'
#' @param se (SummarizedExperiment) - containing expression or next-generation
#'  sequencing data in the "assays" slot and a matrix of phenotype-level data
#'  in the "colData" slot.
#' @param varInt (numeric) - indicating the column of the design matrix
#'  corresponding to the treatment or outcome of interest (in the
#'  \code{colData} slot of the \code{SummarizedExperiment} argument "se").
#' @param normalized (logical) - whether the data included in the \code{assay}
#'  slot of the input \code{SummarizedExperiment} object has been normalized
#'  already. The default is set to \code{TRUE} since it is expected that most
#'  practitioners would apply normalization methods appropriate to the type of
#'  assay being analyzed. If set to \code{FALSE}, median normalization is
#'  performed for microarray (i.e., non-RNA-seq) data.
#' @param ngscounts (logical) - whether the data are counts generated from a
#'  next-generation sequencing (NGS) experiment (e.g., RNA-seq). The default
#'  setting assumes continuous expression measures as generated by platforms
#'  that are microarray-type (i.e., so-called "targeted" assays).
#' @param parallel (logical) - whether or not to use parallelization in the
#'  estimation procedure. Invoking parallelization happens through a
#'  combination of calls to \code{future} and \code{BiocParallel}. If this
#'  argument is set to \code{TRUE}, \code{future::multiprocess} is used,
#'  and if \code{FALSE}, \code{future::sequential} is used, alongside
#'  \code{BiocParallel::bplapply}. Other options for evaluation through
#'  futures may be invoked by setting the argument \code{future_param}.
#' @param bppar_type (character) - specifies the type of backend to be used with
#'  the parallelization invoked by \code{BiocParallel}. Consult the manual page
#'  for \code{BiocParallel::BiocParallelParam} for possible types and
#'  descriptions on their appropriate uses. The default for this argument is
#'  \code{NULL}, which silently uses \code{BiocParallel::DoparParam}.
#' @param future_param (character) - specifies the type of parallelization to be
#'  invoked when using futures for evaluation. For a list of the available
#'  types, please consult the documentation for \code{future::plan}. The default
#'  setting (this argument set to \code{NULL}) silently invokes
#'  \code{future::multiprocess}. Be careful if changing this setting.
#' @param family (character) - specification of error family: "binomial" or
#'  "gaussian".
#' @param subj_ids (numeric vector) - subject IDs to be passed directly to
#   \code{tmle::tmle} when there are repeated measures; measurements on the same
#'  subject should have the exact same numerical identifier; coerced to class
#'  \code{numeric} if not provided in the appropriate form.
#' @param g_lib (char vector) - library of learning algorithms to be used in
#'  fitting the propensity score E[A | W] (the nuisance parameter denoted "g" in
#'  the literature on targeted minimum loss-based estimation).
#' @param Q_lib (char vector) - library of learning algorithms to be used in
#'  fitting the outcome regression E[Y | A, W] (the nuisance parameter denoted
#'  "Q" in the literature on targeted minimum loss-based estimation).
#' @param ci_type The type of confidence interval to be constructed. By default,
#'  confidence intervals are generated based on the normal approximation but
#'  more conservative inference is attainable (and preferable under deviations
#'  from normality) based on concentration inequalities (e.g., the procedures of
#'  Hoeffding, Bernstein, or Bennett) or alternative reference distributions
#'  (e.g., logistic).
#' @param ... Additional arguments to be passed directly to \code{tmle::tmle} in
#'  fitting the targeted minimum loss-based estimator of the average treatment
#'  effect. Consult the documentation of that function for details.
#'
#' @importFrom SummarizedExperiment assay colData rowData SummarizedExperiment
#' @importFrom BiocParallel register bplapply bpprogressbar DoparParam
#' @importFrom future plan multiprocess sequential
#' @importFrom doFuture registerDoFuture
#' @importFrom tibble as_tibble
#'
#' @return S4 object of class \code{biotmle}, generated by sub-classing
#'  \code{SummarizedExperiment}, with additional slots containing \code{tmleOut}
#'  and \code{call}, among others, containing TMLE-based estimates of the
#'  relationship between a biomarker and exposure or outcome variable and the
#'  original call to this function (for user reference), respectively.
#'
#' @export biomarkertmle
#'
#' @examples
#' library(dplyr)
#' library(biotmleData)
#' data(illuminaData)
#' library(SummarizedExperiment)
#' "%ni%" <- Negate("%in%")
#'
#' colData(illuminaData) <- colData(illuminaData) %>%
#'   data.frame() %>%
#'   dplyr::mutate(age = as.numeric(age > median(age))) %>%
#'   DataFrame()
#'
#' varInt_index <- which(names(colData(illuminaData)) %in% "benzene")
#'
#' biomarkerTMLEout <- biomarkertmle(
#'   se = illuminaData[1:2, ],
#'   varInt = varInt_index,
#'   parallel = FALSE,
#'   family = "gaussian",
#'   g_lib = c("SL.mean", "SL.glm"),
#'   Q_lib = "SL.glm"
#' )
#' #
biomarkertmle <- function(se,
                          varInt,
                          normalized = TRUE,
                          ngscounts = FALSE,
                          parallel = TRUE,
                          bppar_type = NULL,
                          future_param = NULL,
                          family = "gaussian",
                          subj_ids = NULL,
                          g_lib = c(
                            "SL.mean", "SL.glm", "SL.earth"
                          ),
                          Q_lib = c(
                            "SL.mean", "SL.glm", "SL.earth", "SL.ranger"
                          ),
                          ci_type = c("normal", "logistic", "bernstein",
                                      "bennett", "hoeffding"),
                          ...) {

  # ============================================================================
  # catch input and return in output object for user convenience
  # ============================================================================
  call <- match.call(expand.dots = TRUE)
  ci_type <- match.arg(ci_type)

  # ============================================================================
  # invoke S4 class constructor for "bioTMLE" object
  # ============================================================================
  biotmle <- .biotmle(
    SummarizedExperiment(
      assays = list(expMeasures = assay(se)),
      rowData = rowData(se),
      colData = colData(se)
    ),
    call = call,
    tmleOut = tibble::as_tibble(matrix(NA, 10, 10)),
    topTable = tibble::as_tibble(matrix(NA, 10, 10))
  )

  # ============================================================================
  # invoke the voom transform from LIMMA if next-generation sequencing data)
  # ============================================================================
  if (ngscounts) {
    voom_out <- rnaseq_ic(biotmle)
    voom_exp <- 2^(voom_out$E)
    assay(se) <- voom_exp
  }

  # ============================================================================
  # set up parallelization based on input
  # ============================================================================
  doFuture::registerDoFuture()
  if (parallel == TRUE) {
    if (!is.null(future_param)) {
      set_future_param <- parse(text = paste0("future", "::", future_param))
      future::plan(eval(set_future_param))
    } else {
      future::plan(future::multiprocess)
    }
  } else if (parallel == FALSE) {
    warning(paste(
      "Sequential evaluation is strongly discouraged.",
      "\n Proceed with caution."
    ))
    future::plan(future::sequential)
  }
  if (!is.null(bppar_type)) {
    bp_type <- eval(parse(text = paste0(
      "BiocParallel", "::",
      bppar_type, "()"
    )))
  } else {
    bp_type <- BiocParallel::DoparParam()
  }
  BiocParallel::bpprogressbar(bp_type) <- TRUE
  BiocParallel::register(bp_type, default = TRUE)

  # ============================================================================
  # TMLE procedure to identify biomarkers based on an EXPOSURE
  # ============================================================================

  # median normalization
  if (!ngscounts && !normalized) {
    Y <- tibble::as_tibble(t(limma::normalizeBetweenArrays(as.matrix(assay(se)),
      method = "scale"
    )))
  } else {
    Y <- tibble::as_tibble(t(as.matrix(assay(se))))
  }
  # simple sanity check of whether Y includes array values
  if (!all(apply(Y, 2, class) == "numeric")) {
    stop("Warning - values in Y do not appear to be numeric...")
  }

  # exposure / treatment
  A <- as.numeric(colData(se)[, varInt])

  # baseline covariates
  W <- tibble::as_tibble(as.data.frame(colData(se)[, -varInt]))
  if (dim(W)[2] == 0) {
    W <- as.numeric(rep(1, length(A)))
  }

  # coerce matrix of baseline covariates to numeric
  if (!all(apply(W, 2, class) == "numeric")) {
    W <- tibble::as_tibble(apply(W, 2, as.numeric))
  }

  # perform multi-level TMLE (of the ATE) for genes as Y
  biomarkerTMLEout <- BiocParallel::bplapply(Y[, seq_along(Y)],
    biomarkerTMLE_exposure,
    W = W,
    A = A,
    a = unique(A),
    g_lib = g_lib,
    Q_lib = Q_lib,
    family = family,
    subj_ids = subj_ids,
    ci_type = ci_type,
    ...
  )
  biomarkerTMLEout <- do.call(cbind.data.frame, biomarkerTMLEout)

  if (!ngscounts) {
    biotmle@tmleOut <- tibble::as_tibble(t(as.matrix(biomarkerTMLEout)))
  } else {
    voom_out$E <- t(as.matrix(biomarkerTMLEout))
    biotmle@tmleOut <- voom_out
  }
  return(biotmle)
}
