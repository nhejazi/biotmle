utils::globalVariables(c("gene","assay<-"))

#' Biomarker Evaluation with Targeted Minimum Loss-Based Estimation (TMLE)
#'
#' Computes the causal target parameter defined as the difference between the
#' biomarker expression values under treatment and those same values under no
#' treatment, using Targeted Minimum Loss-Based Estimation.
#'
#' @param se (SummarizedExperiment) - containing expression or next-generation
#'        sequencing data in the "assays" slot and a matrix of phenotype-level
#'        data in the "colData" slot.
#' @param varInt (numeric) - indicating the column of the design matrix
#'        corresponding to the treatment or outcome of interest (in the
#'        "colData" slot of the "se" argument above).
#' @param ngscounts (logical) - whether the data are counts generated from a
#'        next-generation sequencing (NGS) experiment (e.g., RNA-seq). The
#'        default setting assumes continuous expression measures as generated by
#'        microarray-type platforms.
#' @param parallel (logical) - whether or not to use parallelization in the
#'        estimation procedure. Invoking parallelization happens through a
#'        combination of calls to \code{future} and \code{BiocParallel}. If this
#'        argument is set to \code{TRUE}, \code{future::multiprocess} is used,
#'        and if \code{FALSE}, \code{future::sequential} is used, alongside
#'        \code{BiocParallel::bplapply}. Other options for evaluation through
#'        futures may be invoked by setting the argument \code{future_param}.
#' @param bppar_type (character) - specifies the type of backend to be used with
#'        the parallelization invoked by \code{BiocParallel}. Consult the manual
#'        page for \code{BiocParallel::BiocParallelParam} for possible types and
#'        descriptions on their appropriate uses. The default for this argument
#'        is \code{NULL}, which silently uses \code{BiocParallel::DoparParam}.
#' @param future_param (character) - specifies the type of parallelization to be
#'        invoked when using futures for evaluation. For a list of the available
#'        types, please consult the documentation for \code{future::plan}. The
#'        default setting (this argument set to \code{NULL}) silently invokes
#'        \code{future::multiprocess}. Be careful if changing this setting.
#' @param family (character) - specification of error family: "binomial" or
#'        "gaussian".
#' @param subj_ids (numeric vector) - subject IDs to be passed directly to
#         \code{tmle::tmle} when there are repeated measures; measurements on
#'        the same subject should have the exact same numerical identifier;
#'        coerced to numeric if not provided in the appropriate form.
#' @param g_lib (char vector) - library of learning algorithms to be used in
#'        fitting the "g" step of the standard TMLE procedure.
#' @param Q_lib (char vector) - library of learning algorithms to be used in
#'        fitting the "Q" step of the standard TMLE procedure.
#'
#' @importFrom SummarizedExperiment assay colData rowData SummarizedExperiment
#' @importFrom BiocParallel register bplapply bpprogressbar DoparParam
#' @importFrom future plan multiprocess sequential
#' @importFrom doFuture registerDoFuture
#'
#' @return S4 object of class \code{biotmle}, generated by sub-classing
#'         \code{SummarizedExperiment}, with additional slots containing
#'         \code{tmleOut} and \code{call}, among others, containing TMLE-based
#'         estimates of the relationship between a biomarker and exposure or
#'         outcome variable and the original call to this function (for user
#'         reference), respectively.
#'
#' @export biomarkertmle
#'
#' @examples
#' library(dplyr)
#' library(biotmleData)
#' data(illuminaData)
#' library(SummarizedExperiment)
#' "%ni%" = Negate("%in%")
#'
#' colData(illuminaData) <- colData(illuminaData) %>%
#'      data.frame %>%
#'      dplyr::mutate(age = as.numeric(age > median(age))) %>%
#'      DataFrame
#'
#' varInt_index <- which(names(colData(illuminaData)) %in% "benzene")
#'
#' biomarkerTMLEout <- biomarkertmle(se = illuminaData[1:2, ],
#'                                   varInt = varInt_index,
#'                                   parallel = FALSE,
#'                                   family = "gaussian",
#'                                   g_lib = c("SL.mean", "SL.glm"),
#'                                   Q_lib = "SL.mean"
#'                                  )
#'
biomarkertmle <- function(se,
                          varInt,
                          ngscounts = FALSE,
                          parallel = TRUE,
                          bppar_type = NULL,
                          future_param = NULL,
                          family = "gaussian",
                          subj_ids = NULL,
                          g_lib = c("SL.glm", "SL.randomForest", "SL.nnet",
                                    "SL.polymars", "SL.mean"),
                          Q_lib = c("SL.glm", "SL.randomForest", "SL.nnet",
                                    "SL.mean")
                          ) {

  # ============================================================================
  # catch input and return in output object for user convenience
  # ============================================================================
  call <- match.call(expand.dots = TRUE)

  # ============================================================================
  # invoke S4 class constructor for "bioTMLE" object
  # ============================================================================
  biotmle <- .biotmle(
       SummarizedExperiment(
          assays = list(expMeasures = assay(se)),
          rowData = rowData(se),
          colData = colData(se)
       ),
       call = call,
       tmleOut = as.data.frame(matrix(NA, 10, 10)),
       topTable = as.data.frame(matrix(NA, 10, 10))
   )

  # ============================================================================
  # invoke the voom transform from LIMMA if next-generation sequencing data)
  # ============================================================================
  if (ngscounts) {
    voom_out <- rnaseq_ic(biotmle)
    voom_exp <- 2^(voom_out$E)
    assay(se) <- voom_exp
  }

  #=============================================================================
  # set up parallelization based on input
  # ============================================================================
  doFuture::registerDoFuture()
  if (parallel == TRUE) {
    if (!is.null(future_param)) {
      set_future_param <- parse(text = paste0("future", "::", future_param))
      future::plan(eval(set_future_param))
    } else {
      future::plan(future::multiprocess)
    }
  } else if (parallel == FALSE) {
    warning(paste("Sequential evaluation is strongly discouraged.",
                  "\n Proceed with caution."))
    future::plan(future::sequential)
  }
  if (!is.null(bppar_type)) {
    bp_type <- eval(parse(text = paste0("BiocParallel", "::",
                                        bppar_type, "()")))
  } else {
    bp_type <- BiocParallel::DoparParam()
  }
  BiocParallel::bpprogressbar(bp_type) <- TRUE
  BiocParallel::register(bp_type, default = TRUE)

  #=============================================================================
  # TMLE procedure to identify biomarkers based on an EXPOSURE
  # ============================================================================

  # median normalization
  if (!ngscounts) {
    Y <- as.data.frame(t(limma::normalizeBetweenArrays(assay(se),
                                                       method = "scale")))
  } else {
    Y <- as.data.frame(t(assay(se)))
  }
  # simple sanity check of whether Y includes array values
  if(unique(lapply(Y, class)) != "numeric") {
    stop("Warning - values in Y do not appear to be numeric...")
  }

  # exposure / treatment
  A <- as.numeric(colData(se)[, varInt])

  # baseline covariates
  W <- as.data.frame(colData(se)[, -varInt])
  if(dim(W)[2] == 0) {
    W <- as.numeric(rep(1, length(A)))
  }

  # coerce matrix of baseline covariates to numeric
  if (!all(unique(sapply(W, class)) == "numeric")) {
    W <- as.data.frame(sapply(W, as.numeric))
  }

  # perform multi-level TMLE (of the ATE) for genes as Y
  biomarkerTMLEout <- BiocParallel::bplapply(Y[, seq_along(Y)],
                                             biomarkerTMLE_exposure,
                                             W = W,
                                             A = A,
                                             a = unique(A),
                                             g_lib = g_lib,
                                             Q_lib = Q_lib,
                                             family = family,
                                             subj_ids = subj_ids
                                            )
  biomarkerTMLEout <- do.call(cbind.data.frame, biomarkerTMLEout)

  if (ngscounts) {
    voom_out$E <- t(biomarkerTMLEout)
    biotmle@tmleOut <- voom_out
  } else {
    biotmle@tmleOut <- as.data.frame(t(biomarkerTMLEout))
  }
  return(biotmle)
}
