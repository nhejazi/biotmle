utils::globalVariables(c("assay<-"))

#' Biomarker Evaluation with Targeted Minimum Loss Estimation of the ATE
#'
#' Computes the causal target parameter defined as the difference between the
#' biomarker expression values under treatment and those same values under no
#' treatment, using Targeted Minimum Loss Estimation.
#'
#' @param se A \code{SummarizedExperiment} containing microarray expression
#'  or next-generation sequencing data in the \code{assays} slot and a matrix of
#'  phenotype-level data in the \code{colData} slot.
#' @param varInt A \code{numeric} indicating the column of the design matrix
#'  corresponding to the treatment or outcome of interest (in the
#'  \code{colData} slot of the \code{SummarizedExperiment} argument "se").
#' @param normalized (logical) - whether the data included in the \code{assay}
#'  slot of the input \code{SummarizedExperiment} object has been normalized
#'  already. The default is set to \code{TRUE} with the expectation that a
#'  normalization method has been applied, appropriate to the type of assay
#'  being analyzed. If set to \code{FALSE}, median normalization is performed
#'  for microarray (i.e., non-RNA-seq) data.
#' @param ngscounts (logical) - whether the data are counts generated from a
#'  next-generation sequencing (NGS) experiment (e.g., RNA-seq). The default
#'  setting assumes continuous expression measures as generated by platforms
#'  that are microarray-type (i.e., so-called "targeted" assays).
#' @param parallel (logical) - whether or not to use parallelization in the
#'  estimation procedure. Invoking parallelization happens through a
#'  combination of calls to \pkg{future} and \pkg{BiocParallel}. If this
#'  argument is set to \code{TRUE}, \code{\link[future]{multiprocess}} is used,
#'  and if \code{FALSE}, \code{\link[future]{sequential}} is used, alongside
#'  \code{\link[BiocParallel]{bplapply}}. Other options for evaluation through
#'  futures may be invoked by setting the argument \code{future_param}.
#' @param bppar_type (character) - specifies the type of backend to be used with
#'  the parallelization invoked by \code{BiocParallel}. Consult the manual page
#'  for \code{\link[BiocParallel]{BiocParallelParam}} for possible types and
#'  descriptions on their appropriate uses. The default for this argument is
#'  \code{NULL}, which silently uses \code{\link[BiocParallel]{DoparParam}}.
#' @param future_param (character) - specifies the type of parallelization to be
#'  invoked when using futures for evaluation. For a list of the available
#'  types, please consult the documentation for \code{\link[future]{plan}}. The
#'  default setting (this argument set to \code{NULL}) silently invokes
#'  \code{\link[future]{multiprocess}}. Be careful if changing this setting.
#' @param subj_ids (numeric vector) - subject IDs to be passed directly to
#   \code{\link[tmle]{tmle}} when there are repeated measures; measurements on
#'  the same subject should have the exact same numerical identifier; coerced to
#'  class \code{numeric} if not provided in the appropriate form.
#' @param cv_folds A \code{numeric} scalar indicating how many folds to use in
#'  performing targeted minimum loss estimation. Cross-validated estimates are
#'  more robust, allowing relaxing of theoretical conditions and construction of
#'  conservative variance estimates.
#' @param g_lib (char vector) - library of learning algorithms to be used in
#'  fitting the propensity score E[A | W] (the nuisance parameter denoted "g" in
#'  the literature on targeted minimum loss-based estimation).
#' @param Q_lib (char vector) - library of learning algorithms to be used in
#'  fitting the outcome regression E[Y | A, W] (the nuisance parameter denoted
#'  "Q" in the literature on targeted minimum loss-based estimation).
#' @param ... Additional arguments to be passed to \code{\link[tmle]{tmle}} in
#'  fitting the targeted minimum loss estimator of the average treatment effect.
#'
#' @importFrom SummarizedExperiment assay colData rowData SummarizedExperiment
#' @importFrom BiocParallel register bplapply bpprogressbar DoparParam
#' @importFrom future plan multiprocess sequential
#' @importFrom doFuture registerDoFuture
#' @importFrom tibble as_tibble
#'
#' @return S4 object of class \code{biotmle}, generated by sub-classing
#'  \code{SummarizedExperiment}, with additional slots containing \code{tmleOut}
#'  and \code{call}, among others, containing TMLE-based estimates of the
#'  relationship between a biomarker and exposure or outcome variable and the
#'  original call to this function (for user reference), respectively.
#'
#' @export biomarkertmle
#'
#' @examples
#' library(dplyr)
#' library(biotmleData)
#' data(illuminaData)
#' library(SummarizedExperiment)
#' "%ni%" <- Negate("%in%")
#'
#' colData(illuminaData) <- colData(illuminaData) %>%
#'   data.frame() %>%
#'   dplyr::mutate(age = as.numeric(age > median(age))) %>%
#'   DataFrame()
#'
#' varInt_index <- which(names(colData(illuminaData)) %in% "benzene")
#'
#' biomarkerTMLEout <- biomarkertmle(
#'   se = illuminaData[1:2, ],
#'   varInt = varInt_index,
#'   parallel = FALSE,
#'   g_lib = c("SL.mean", "SL.glm"),
#'   Q_lib = "SL.glm"
#' )
biomarkertmle <- function(se,
                          varInt,
                          normalized = TRUE,
                          ngscounts = FALSE,
                          parallel = TRUE,
                          bppar_type = NULL,
                          future_param = NULL,
                          subj_ids = NULL,
                          cv_folds = 5,
                          g_lib = c(
                            "SL.mean", "SL.glm", "SL.glmnet", "SL.earth"
                          ),
                          Q_lib = c(
                            "SL.mean", "SL.glm", "SL.randomForest"
                          ),
                          ...) {

  # ===========================================================================
  # catch input and return in output object for user convenience
  # ===========================================================================
  call <- match.call(expand.dots = TRUE)

  # ===========================================================================
  # invoke S4 class constructor for "bioTMLE" object
  # ===========================================================================
  biotmle <- .biotmle(
    SummarizedExperiment(
      assays = list(expMeasures = assay(se)),
      rowData = rowData(se),
      colData = colData(se)
    ),
    call = call,
    tmleOut = tibble::as_tibble(matrix(NA, 10, 10)),
    topTable = tibble::as_tibble(matrix(NA, 10, 10))
  )

  # ===========================================================================
  # invoke the voom transform from LIMMA if next-generation sequencing data)
  # ===========================================================================
  if (ngscounts) {
    voom_out <- rnaseq_ic(biotmle)
    voom_exp <- 2^(voom_out$E)
    assay(se) <- voom_exp
  }

  # ===========================================================================
  # set up parallelization based on input
  # ===========================================================================
  doFuture::registerDoFuture()
  if (parallel == TRUE) {
    if (!is.null(future_param)) {
      set_future_param <- parse(text = paste0("future", "::", future_param))
      future::plan(eval(set_future_param))
    } else {
      future::plan(future::multiprocess)
    }
  } else if (parallel == FALSE) {
    warning(paste(
      "Sequential evaluation over many probes may take a long time."
    ))
    future::plan(future::sequential)
  }
  if (!is.null(bppar_type)) {
    bp_type <- eval(parse(text = paste0(
      "BiocParallel", "::",
      bppar_type, "()"
    )))
  } else {
    bp_type <- BiocParallel::DoparParam()
  }
  BiocParallel::bpprogressbar(bp_type) <- TRUE
  BiocParallel::register(bp_type, default = TRUE)

  # ===========================================================================
  # TMLE procedure to identify biomarkers based on an EXPOSURE
  # ===========================================================================

  # median normalization
  if (!ngscounts && !normalized) {
    Y <- tibble::as_tibble(t(limma::normalizeBetweenArrays(as.matrix(assay(se)),
      method = "scale"
    )))
  } else {
    Y <- tibble::as_tibble(t(as.matrix(assay(se))))
  }
  # simple sanity check of whether Y includes array values
  if (!all(apply(Y, 2, class) == "numeric")) {
    stop("Warning - values in Y do not appear to be numeric.")
  }

  # exposure / treatment
  A <- as.numeric(colData(se)[, varInt])

  # baseline covariates
  W <- tibble::as_tibble(as.data.frame(colData(se)[, -varInt]))
  if (dim(W)[2] == 0) {
    W <- as.numeric(rep(1, length(A)))
  }

  # coerce matrix of baseline covariates to numeric
  if (!all(apply(W, 2, class) == "numeric")) {
    W <- tibble::as_tibble(apply(W, 2, as.numeric))
  }

  # perform multi-level TMLE (of the ATE) for genes as Y
  biomarkerTMLEout <- BiocParallel::bplapply(Y[, seq_along(Y)],
    biomarkerTMLE_exposure,
    W = W,
    A = A,
    a = sort(unique(A)),
    g_lib = g_lib,
    Q_lib = Q_lib,
    cv_folds = cv_folds,
    subj_ids = subj_ids,
    ...
  )
  biomarkerTMLEout <- do.call(cbind.data.frame, biomarkerTMLEout)

  if (!ngscounts) {
    biotmle@tmleOut <- tibble::as_tibble(t(as.matrix(biomarkerTMLEout)))
  } else {
    voom_out$E <- t(as.matrix(biomarkerTMLEout))
    biotmle@tmleOut <- voom_out
  }
  return(biotmle)
}
